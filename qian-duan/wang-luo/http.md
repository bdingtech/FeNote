---
description: HTTP是前端开发中接触到最多的应用层协议，搞清楚HTTP对开发会有比较大的帮助
---

# HTTP

## GET和POST有什么区别

* **传输方式**不同：GET请求通过URL传输数据，而POST请求通过请求体传输
* **安全性**不同：POST中的数据因为在请求体中，所以具有一定的安全性，而GET的数据在URL中，通过历史记录、缓存等方式很容易查到数据信息
* **传输数据类型**不同：GET只允许ASCLI字符，而POST无限制
* **长度**不同：GET有限制,URL最大限度为2048个字符，post无限制；
* GET无害：刷新、后退等浏览器操作请求时无害的（意思是从`method`的定义上，`get`是幂等的，执行多少遍不影响最终存储的结果。而`post`每次调用都会创建新的资源），而POST可能重复表单提交

## HTTP的请求和响应报文报文是怎样的？

### 请求报文

请求报文有4部分组成:

* 请求行
* 请求头部
* 换行符
* 请求体

![](../../.gitbook/assets/image%20%2852%29.png)

![](../../.gitbook/assets/image%20%2851%29.png)

### 响应报文

和请求报文一样，也是由**响应行**、**响应头**、**换行符**、**响应体**组成

![](../../.gitbook/assets/image%20%2856%29.png)

## 聊一聊HTTP状态码有哪些

![](../../.gitbook/assets/image%20%2858%29.png)

### 2XX 成功

#### 200 OK

代表请求被正常处理了

#### 204 No Content

该状态码代表服务器接收的请求已成功处理，但在返回的响应报文 中不含实体的主体部分。

![](../../.gitbook/assets/image%20%2850%29.png)

#### 206 Partial（部分） Content

可以告诉服务端自己需要下载那一部分内容，多用于下载、视频播放场景

### 3XX 重定向

#### 303 See Other（强调使用GET方法重定向）

303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明 确表示客户端应当采用 **GET** 方法获取资源，这点与 302 状态码有区别。

#### 307 Temporary Redirect（按照原来的请求方式重定向）

临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标 准禁止 POST 变换成 GET，但实际使用时大家并不遵守。

307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理 响应时的行为，每种浏览器有可能出现不同的情况。

#### 304 Not Modified

常用于协商缓存时，当浏览器将If-Modified- Since，If-None-Match等信息发送给服务端，服务端判断资源没有更新时，则响应304状态码，304状态码返回时，不包括任何响应的主体部分，所以能节省数据资源，提高请求速度

#### 4XX 客户端错误

#### 400 Bad Request

![](../../.gitbook/assets/image%20%2855%29.png)

![](../../.gitbook/assets/image%20%2853%29.png)

该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

#### 403 Forbidden

该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必 要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分 对原因进行描述，这样就能让用户看到了。

未获得文件系统的访问授权，访问权限出现某些问题\(从未授权的 发送源 IP 地址试图访问\)等列举的情况都可能是发生 403 的原因。

### 5XX 服务器错误

#### 500 Internal Server Error

![](../../.gitbook/assets/image%20%2854%29.png)

该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。

#### 503 Service Unavailable

![](../../.gitbook/assets/image%20%2857%29.png)

该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry- After 首部字段再返回给客户端。

## 什么时候会触发强制缓存或者协商缓存？

### 强制缓存

强缓存离不开两个响应头 Expires（ http1.0 ） 与 Cache-Control \( 较常用 \)

![](../../.gitbook/assets/image%20%2848%29.png)

目前主流的做法使用 Cache-Control 控制缓存，除了 max-age 控制过期时间外，还有一些不得不提

* Cache-Control: public可以被所有用户缓存，包括终端和CDN等中间代理服务器
* Cache-Control: private只能被终端浏览器缓存，不允许中继缓存服务器进行缓存
* Cache-Control: no-cache,先缓存本地，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使用
* Cache-Control: no-store，不会产生任何缓存 

所以，当Cache-Control 设置为public或者private时，会触发强制缓存策略，为no-cache时，先缓存，但是只有和服务器验证之后才能时候

### 协商缓存

当请求头中没有Cache-Control和Expires时，或者过期的时候，则命中协商缓存

## HTTP的缓存的过程是怎样的?

1. 客户端向服务器发送请求
2. 服务器返回资源，并且通过响应头决定缓存策略
3. 客户端根据缓存策决定是否将资源缓存下来，分为两种情况，一种是强制缓存、一种是协商缓存
4. 当客户端再次发起请求时，则根据缓存策略，如果是强制缓存，则命中缓存后直接返回缓存资源，不再发起请求，如果是协商缓存，则将上一次浏览器返回的ETag或者Last-Modified发送给浏览器，由浏览器进行判断，如果是304则无需再次下载该资源，直接从缓存中读取，反之返回200，携带新的请求头和数据

### 第一次请求（无缓存）

![](../../.gitbook/assets/image%20%2847%29.png)

HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类\(**强制缓存**，**协商缓存\)**

### **第二次请求-强制缓存**

缓存命中则直接返回，而未命中则向服务器返回数据

![](../../.gitbook/assets/image%20%2846%29.png)

### 第二次请求-协商缓存

当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期抑或它的属性设 置为no-cache时，那么浏览器第二次请求时就会与服务器进行协商。

![](../../.gitbook/assets/image%20%2849%29.png)

#### **Etag / If-None-Match**（优先级高于Last-Modified / If-Modified-Since）

#### **Last-Modified / If-Modified-Since**

\*\*\*\*

