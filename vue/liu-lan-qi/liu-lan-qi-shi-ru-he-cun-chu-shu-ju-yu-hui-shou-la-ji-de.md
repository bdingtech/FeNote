---
title: 浏览器是如何存储数据与回收垃圾的?
date: '2020-06-05T16:21:05.000Z'
category:
  - 浏览器
tags:
  - 垃圾回收
  - 数据模型
---

# 浏览器是如何存储数据与回收垃圾的 ？

## 如何存储数据？

既然要讨论浏览器是如何存储数据的，那我们本身就应该知道我们要存储一些什么数据，也就是Javascript有一些什么数据类型，以及其存储空间的种类是怎样的，其实 JavaScript 中的数据类型一种有 8 种，它们分别是：

### JavaScript的数据类型

**除了Object是引用类型外，其他都是原始类型**

![img](https://img-1251598303.cos.ap-guangzhou.myqcloud.com/85b87602eac65356c9171bbd023f5715.png)

> 使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。

### JavaScript的内存模型

从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。

![img](https://img-1251598303.cos.ap-guangzhou.myqcloud.com/6293f5315a5bafbd3ba00ee732bfbf57.png)

在游览器中**原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的**，因为为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。

如果是引用类型，JavaScript引擎并不是直接将该对象放在变量环境，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：

![img](https://img-1251598303.cos.ap-guangzhou.myqcloud.com/22100df5c75fb51037d7a929777c57bc.png)

在 JavaScript 中，赋值操作和其他语言有很大的不同，**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**。所以d=c的操作就是把 c 的引用地址赋值给 d，你可以参考下图：

![img](https://img-1251598303.cos.ap-guangzhou.myqcloud.com/51127624a725a18a0e12e0f5a7aadbf5.png)

### 小结

1. 原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的
2. 原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址，正是因为JavaScript存在这种机制，所以才会出现深克隆、浅克隆等操作
3. 在JavaScript中除了Object是引用类型外，其他都是原始类型

## 如何回收垃圾？

### 什么是垃圾，为什么要回收？

有些数据被使用之后，可能就不再需要了，我们把这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间。垃圾数据回收分为手动回收和自动回收两种策略，如 C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的，另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。对于 JavaScript 而言，也正是这个“自动”释放资源的特性带来了很多困惑，也让一些 JavaScript 开发者误以为可以不关心内存管理，这是一个很大的误解。

### 什么地方会产生垃圾？

既然刚刚说到JavaScript的内存模型分为代码空间、栈空间和堆空间，而数据就是存储在栈空间和堆空间中，所以就是回收这两个地方的垃圾，但是因为这两个地方的用途以及存储结构不同，所以对应的回收机制也不尽相同。

### 调用栈中的垃圾是怎么回收的？

首先我们要引入一个很关键的东西，「 **记录当前执行状态的指针（称为 ESP）**」，通过ESP指针的移动就能实现切换执行上下文同时也可以销毁执行上下文

![img](https://img-1251598303.cos.ap-guangzhou.myqcloud.com/b1f0573287b487016334c3f8ec23073b.png)

当ESP指针往下移动到另外一个函数的执行上下文的时候，上一个函数的执行上下文虽然保存在栈内存中，但是已经是无效内存了，当再次调用另外一个函数时，另外一个函数的执行上下文会直接覆盖掉上一个函数的执行上下文，从而实现了垃圾回收。

所以说，当一个函数执行结束之后，**JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文**。

### 堆中的数据是如何回收的

当一个函数执行完，通过ESP指针的移动，我们已经对栈空间里面的垃圾进行回收重新利用了，但是还有一个问题，我们的引用类型的数据可是存在堆空间中的啊，这一块的垃圾咋办？接下来我们就来讨论一下堆空间的垃圾是咋回收的。

![img](https://img-1251598303.cos.ap-guangzhou.myqcloud.com/e80ff553417572f77973b08256b6928c.png)

从图中可以看出，1003 和 1050 这两块内存依然被占用。要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。

#### 代际假说（The Generational Hypothesis）和分代收集

代际假说有以下两个特点：

* 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
* 第二个是不死的对象，会活得更久。

代际假说简单来讲就是将需要回收的垃圾进行分类，像在浏览器的V8引擎中会把堆分为**新生代**和**旧生代**连个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

分代收集的意思就是对新生代和旧生代采用不同的回收方法

### 垃圾回收的工作流程

我们采用主垃圾回收器和副垃圾回收器来分别对新老生代进行回收，以实现高效率的垃圾回收。

* 副垃圾回收器，主要负责新生代的垃圾回收。
* 主垃圾回收器，主要负责老生代的垃圾回收。

#### 大体上的执行流程（细节差异化）

`（标记 ->回收->整理 ）`

1. 标记空间中的活动对象与非活动对象
2. 回收非活动对象所占据的内存，就是在标记完成之后统一清除标记的非活动对象
3. 内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

#### 副垃圾回收器（标记-&gt;复制-&gt;删除）-新生区

副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。新生代中用 **Scavenge** 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：

![img](https://img-1251598303.cos.ap-guangzhou.myqcloud.com/4f9310c7da631fa5a57f871099bfbeaf.png)

在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

#### 主垃圾回器（标记-&gt;删除）-老生区

主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。

由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：

![img](https://img-1251598303.cos.ap-guangzhou.myqcloud.com/d015db8ad0df7f0ccb1bdb8e31f96e85.png)

上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：

![img](https://img-1251598303.cos.ap-guangzhou.myqcloud.com/652bd2df726d0aa5e67fe8489f39a18c.png)

### 全停顿与增量标记算法

因为JavaScript是运行在主进程的，一旦执行垃圾回收算法，现在正在执行的JavaScript脚本便会停止下来，等待回收完毕再恢复脚本的执行，所以这种行为叫**全停顿（Stop-The-World）**

![img](https://img-1251598303.cos.ap-guangzhou.myqcloud.com/9898646a08b46bce4f12f918f3c1e60c.png)

> 全停顿对空间较小，且存活对象较少的新生代垃圾回收的影响不大，但是老生代就不一样了，老生代的数据量大，回收起来需要时间，严重的会造成页面的卡顿现象

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：

![img](https://img-1251598303.cos.ap-guangzhou.myqcloud.com/de117fc96ae425ed90366e9060aa14e7.png)

## 总结

首先我们介绍了游览器是如果储存数据的，接下来又探讨了如何对这些储存的数据进行回收。浏览器的奥秘还远不止这些，更多更深层次的东西还等这我们去探索。

`“我们生活在一个极其复杂的世界”`，这是我最近读了有关计算机网络相关书籍之后的体会，单单从我们在网页中的每次点击到屏幕上显示图像文字这个过程来看，前辈们为了更快更高效的实现这个过程，就不知道付出了多少心血与努力，这还是单单从我们生活中的一个特别小，小到不足为奇的点来看，如果从宏观的视角来看，人类一代又一代的不断积累知识，而一代又一代根据现有的知识去创造新的知识，才使我们现在的生活质量不断的提高，获取信息的途径也多种多样，我们需要对自然怀以敬畏之心，同样，我们也必须对祖先和先辈们留给我们的知识保持敬畏之心。

